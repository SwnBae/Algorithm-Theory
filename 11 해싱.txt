해싱?
insert, search, delete에 특화된 자료구조, dictionary
O(1)
ordering을 할 수 없음, 비용이 많이 든다.
!충돌을 최소화 시킬 수 있어야함 ( 같은 슬롯에 여러키)
-> 충돌을 최소화 할 수 있는 hash function


Chaining (별도의 기억장소가 필요)
 linked list에 pointer 저장

insert - O(1)
delete - O(1) [doubly-linked list일 경우]
search - 길이에 따라 달라진다. 모든 n캐의 키가 같은 슬롯에 있는 경우 Θ(n)

일반적인 경우? 적재율 a = n/m (n은 키의 개수, 모든 요소들이 들어갈 확률은 1/m으로 동일)
a는 체인에 들어있는 요소들의 평균을 나타낸다.

#해시테이블에서 원하는 항목을 찾지 못했을 때
우리가 찾으려고 하는 키 k를 해시 테이블에서 검색할 때, 해시 함수 **h(k)**가 반환하는 위치 **T[h(k)]**를 먼저 확인해. + 패한 검색의 경우, 해당 슬롯에 저장된 모든 항목을 검사하게 돼. 검사해야 하는 항목의 기대값은 α와 같아. 이는 평균적으로 해당 슬롯에 α개의 항목이 있다는 뜻이야.
 = Θ(1 + α)

#해시테이블에서 원하는 항목을 찾았을 때
 Θ(1 + α)


Open Addressing (테이블 내 빈 공간 활용)
-어떤 절차로 빈 공간을 찾을지?
 Delection이 어려움

-Linear probing
충돌 상황에서 선형 탐사법은 값이 저장된 이후의 빈 공간을 탐색하여 값을 저장한다.
h(k,i) = (h1(k) + i) mod m
i=0,1,2,…

probe sequence: < h1(k), h1(k)+1 , h1(k)+2 , ....>
한개씩 늘려가며 빈 공간 찾기
3. 해당 위치에서 충돌이 일어난 경우?
만약 계속 충돌이 발생한다면, 테이블의 마지막 슬롯에 도달했을 때는 다시 테이블의 처음으로 돌아가서 탐사를 이어 나가.
이 과정은 우리가 찾고 있는 키를 발견하거나, 빈 슬롯을 발견할 때까지 계속돼.

#Deleting a key할때 문제
 삭제 문제 발생:
만약 중간에 있는 항목을 삭제하고 그 슬롯을 빈 상태로 만들어 버리면, 나중에 그 슬롯 뒤에 저장된 항목들을 찾을 때 문제가 발생해. 왜냐하면 검색 도중 빈 슬롯을 만나면 해당 키가 없다고 판단하기 때문이야.
예를 들어, 키 A를 슬롯 3에, 키 B를 슬롯 4에 저장했다고 가정해 보자. 나중에 키 A를 삭제하고 슬롯 3을 빈 상태로 만들면, 키 B를 찾으려는 탐색이 슬롯 3에서 끝나버릴 수 있어.

-> Lazy Delete (지연 삭제 방법):
키를 완전히 삭제하는 대신, 해당 항목을 비활성화 상태로 표시

#Primary Clustering Problem
슬롯 사용의 불균형:
해시 테이블에 여러 개의 키를 삽입하다 보면, 특정 해시 값(즉, 특정 슬롯)에 여러 키가 몰리게 될 수 있어. 이렇게 되면 그 슬롯과 그 다음 슬롯들이 차례로 점유되면서 긴 연속된 점유 슬롯이 형성돼.

연속된 점유 슬롯:
예를 들어, 해시 테이블에서 슬롯 2와 슬롯 3, 슬롯 4가 이미 사용 중이라면, 해시 함수의 결과가 슬롯 1일 때는 그 슬롯이 비어 있으니 쉽게 삽입될 수 있지만, 슬롯 5에 삽입하려면 슬롯 1, 2, 3, 4를 모두 확인해야 해. 이처럼 특정 슬롯이 많이 점유되면, 그 슬롯 뒤에 있는 슬롯들을 모두 탐색해야 할 가능성이 커지기 때문에 탐색 시간이 증가해.

길어진 탐색 시간:
이렇게 긴 연속된 점유 슬롯이 생기면, 새로운 키를 삽입하거나 기존 키를 검색할 때 확인해야 할 슬롯의 수가 많아지게 돼. 이로 인해 삽입 및 검색의 평균 시간이 증가하게 되는 거야. 특히, 슬롯이 점점 더 많이 점유되면 슬롯을 탐색하는 과정이 길어지고, 효율이 떨어지게 돼.

-Quadratic probing
• h(k,i) = (h'(k) + c1*i + c2*i^2) mod m c1!= c2
여유 있게 점프

#secondary clustering:
두 개의 키가 같은 초기 프로브 위치를 가지면, 두 키 모두 같은 2차 함수에 따라 프로브를 하게 돼. 즉, 이 두 키는 동일한 슬롯들을 순차적으로 탐색하게 되고, 이는 특정 슬롯에 대한 충돌이 반복적으로 발생할 수 있음을 의미해.
예를 들어, 만약 키 A와 키 B가 같은 초기 해시 값을 가지면, 이들은 동일한 방식으로 슬롯을 탐색하게 되므로, 두 키는 서로의 탐색에 영향을 주게 되지.

-Double Hashing

Double Hashing에서는 두 개의 해시 함수를 사용해:
첫 번째 해시 함수 h1(k)는 키 k의 초기 슬롯을 결정해.
두 번째 해시 함수 h2(k)는 프로브(탐색) 시퀀스의 증가량을 결정해.

초기 프로브는 h1(k)에서 시작하고, 이후의 프로브는 h2(k)에 따라 증가된 위치에서 진행돼.

#클러스터링 문제는 해결 가능하지만, delete가 어렵다.



Open Addressing의 가정
1. n<m
2. uniform hashing :충돌이 발생할 확률이 동일하다고 가정합니다.
3. no delection
4. All probe sequences are equally likely 충돌이 발생했을 때, 각 프로브가 빈 슬롯을 찾는 과정에서의 순서와 선택이 균등

Rehashing
테이블이 너무 가득 차게 되면 기본적인 연산의 실행 시간이 저하

리해싱 과정
1.기존 해시 테이블 복사: 현재의 해시 테이블을 복사해.
2.테이블 크기 증가: 해시 테이블의 크기를 두 배로 늘려.
3.이전 테이블의 모든 요소 재삽입: 복사한 이전 테이블의 모든 요소를 새로운 테이블에 삽입해. 이 과정에서 해시 함수를 사용하여 새 슬롯에 적절히 배치해.

#비용이 매우 비싸다.

해시값을 이용해 파일의 위변조를 판별할 수 있다.
